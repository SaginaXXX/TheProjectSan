# 性能问题排查与修复方案 - 刷新变卡问题

> **问题**: 刷新几次或打开关闭网页几次会变卡  
> **原因**: 多个资源泄漏点  
> **严重性**: 🔴 严重（影响用户体验）

---

## 🔍 问题分析

### 症状

- 刷新 3-5 次后页面变卡
- 打开关闭网页多次后响应变慢
- 可能出现内存占用持续增长

### 典型的内存泄漏表现

```
第 1 次刷新: 流畅 ✅
第 2 次刷新: 流畅 ✅
第 3 次刷新: 略卡 🟡
第 4 次刷新: 明显卡顿 🔴
第 5 次刷新: 严重卡顿 🔴
```

---

## 🚨 发现的泄漏点

### 泄漏点 1: 广告轮播的 setTimeout 未清理 🔴

**文件**: `components/advertisement/ad-carousel.tsx`

**问题代码**（第 154-175 行）：

```typescript
const fetchAdvertisements = useCallback(async () => {
  // 延迟发送请求
  setTimeout(() => {
    sendMessage(toolRequest);
  }, 500);  // ❌ 这个 setTimeout 没有清理！
  
  // 设置超时
  setTimeout(() => {
    if (isLoading) {
      console.error('❌ 广告列表请求超时');
      setIsLoading(false);
    }
  }, 8000);  // ❌ 这个 setTimeout 也没有清理！
}, [sendMessage, isLoading]);
```

**问题**：
- 每次刷新都会创建新的定时器
- 定时器引用的闭包会持有组件状态
- 定时器不会随组件卸载而清除
- **累积效应**: 刷新 5 次 = 10 个未清理的定时器！

**影响**：
- 🔴 内存泄漏（每次泄漏 ~5KB）
- 🔴 定时器继续执行（可能触发已卸载组件的 setState）
- 🔴 可能导致控制台警告和错误

---

### 泄漏点 2: adAudioMonitor 回调可能重复添加 🟡

**文件**: `components/advertisement/ad-carousel.tsx`

**问题代码**（第 390-414 行）：

```typescript
useEffect(() => {
  if (isAudioMode && enableAudioWithVAD) {
    const handleAudioUpdate = (info: AdAudioInfo) => {
      setAudioInfo(info);
      
      if (info.isPlaying !== audioInfo.isPlaying) {
        sendMessage({...});  // ← 这个回调引用了外部状态
      }
    };

    adAudioMonitor.addCallback(handleAudioUpdate);
    
    return () => {
      adAudioMonitor.removeCallback(handleAudioUpdate);
    };
  }
}, [isAudioMode, enableAudioWithVAD, audioInfo.isPlaying, sendMessage]);
//                                    ^^^^^^^^^^^^^^^^  ← 依赖变化会重新订阅
```

**问题**：
- `audioInfo.isPlaying` 在依赖数组中
- 每次 `audioInfo` 变化都会重新订阅
- 可能导致回调被多次添加

**影响**：
- 🟡 同一个回调被调用多次
- 🟡 性能下降

---

### 泄漏点 3: 事件监听器可能重复添加 🟡

**文件**: `components/advertisement/ad-carousel.tsx`

**第 236-266 行**：

```typescript
useEffect(() => {
  const handleAdvertisementChange = (event: CustomEvent) => {
    // ... 处理逻辑
  };

  window.addEventListener('advertisementListChanged', handleAdvertisementChange);
  
  return () => {
    window.removeEventListener('advertisementListChanged', handleAdvertisementChange);
  };
}, [isVisible, isConnectionReady, fetchAdvertisements]);
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ ← 这些依赖变化会重新添加监听器
```

**问题**：
- `fetchAdvertisements` 在依赖数组中
- `fetchAdvertisements` 依赖于 `isLoading`
- 可能导致监听器重复添加

---

### 泄漏点 4: video 元素事件监听器未清理 🔴

**文件**: `components/advertisement/ad-carousel.tsx`

**第 286-372 行**：

```typescript
useEffect(() => {
  const video = videoRef.current;
  if (!video || !isVisible || advertisements.length === 0) return;

  // 添加事件监听器
  video.addEventListener('canplay', startPlayback, { once: true });
  video.addEventListener('loadeddata', handleLoadedData, { once: true });
  video.addEventListener('error', handleError, { once: true });
  
  // ✅ 返回清理函数
  return cleanup;
}, [isVisible, currentIndex, advertisements, isAudioMode, enableAudioWithVAD, sendMessage, baseUrl]);
```

**问题**：
- 虽然有 `{ once: true }`，但如果事件未触发
- cleanup 函数可能在事件监听器添加前就执行了
- 可能导致监听器残留

---

### 泄漏点 5: WebSocket 订阅监控的定时器 🟢

**文件**: `services/websocket-handler.tsx`

**第 437-444 行**：

```typescript
const monitorInterval = process.env.NODE_ENV === 'development' 
  ? setInterval(() => {
      const counts = wsService.getSubscriptionCount();
      console.debug('📊 订阅监控:', counts);
      if (counts.message > 2 || counts.state > 2) {
        console.warn('⚠️  检测到订阅泄漏！订阅数量异常:', counts);
      }
    }, 30000)  // 每30秒检查
  : null;
```

**观察**：
- ✅ 有清理逻辑（第 449-452 行）
- ✅ 这个基本没问题

---

## ✅ 修复方案

### 修复 1: 清理 setTimeout（高优先级）

```typescript
// ❌ Before
const fetchAdvertisements = useCallback(async () => {
  setTimeout(() => {
    sendMessage(toolRequest);
  }, 500);  // 未清理
  
  setTimeout(() => {
    if (isLoading) setIsLoading(false);
  }, 8000);  // 未清理
}, [sendMessage, isLoading]);

// ✅ After
const fetchAdvertisements = useCallback(async () => {
  const timer1 = setTimeout(() => {
    sendMessage(toolRequest);
  }, 500);
  
  const timer2 = setTimeout(() => {
    if (isLoading) setIsLoading(false);
  }, 8000);
  
  // 保存定时器 ID 以便清理
  timeoutRefs.current.push(timer1, timer2);
}, [sendMessage, isLoading]);

// 在组件卸载时清理
useEffect(() => {
  return () => {
    timeoutRefs.current.forEach(clearTimeout);
    timeoutRefs.current = [];
  };
}, []);
```

---

### 修复 2: 稳定 adAudioMonitor 回调

```typescript
// ❌ Before
useEffect(() => {
  const handleAudioUpdate = (info: AdAudioInfo) => {
    setAudioInfo(info);
    if (info.isPlaying !== audioInfo.isPlaying) {  // ← 依赖外部状态
      sendMessage({...});
    }
  };
  
  adAudioMonitor.addCallback(handleAudioUpdate);
  return () => adAudioMonitor.removeCallback(handleAudioUpdate);
}, [audioInfo.isPlaying, sendMessage]);  // ← 依赖变化导致重新订阅

// ✅ After
const audioInfoRef = useRef(audioInfo);
useEffect(() => { audioInfoRef.current = audioInfo; }, [audioInfo]);

useEffect(() => {
  const handleAudioUpdate = (info: AdAudioInfo) => {
    setAudioInfo(info);
    if (info.isPlaying !== audioInfoRef.current.isPlaying) {  // ← 使用 ref
      sendMessage({...});
    }
  };
  
  adAudioMonitor.addCallback(handleAudioUpdate);
  return () => adAudioMonitor.removeCallback(handleAudioUpdate);
}, [sendMessage]);  // ← 只依赖稳定的函数
```

---

### 修复 3: 使用 useCallback 稳定函数引用

```typescript
// ❌ Before
useEffect(() => {
  const handleChange = (event) => { ... };
  window.addEventListener('advertisementListChanged', handleChange);
  return () => window.removeEventListener('advertisementListChanged', handleChange);
}, [fetchAdvertisements]);  // ← fetchAdvertisements 变化导致重新添加

// ✅ After  
const handleChangeRef = useRef<any>(null);

const handleAdvertisementChange = useCallback((event) => {
  // 逻辑...
}, []);  // ← 稳定的回调

useEffect(() => {
  handleChangeRef.current = handleAdvertisementChange;
}, [handleAdvertisementChange]);

useEffect(() => {
  const handler = (event) => handleChangeRef.current?.(event);
  window.addEventListener('advertisementListChanged', handler);
  return () => window.removeEventListener('advertisementListChanged', handler);
}, []);  // ← 不再重复添加
```

---

### 修复 4: 使用 resourceManager 统一管理

```typescript
import { resourceManager } from '@/utils/resource-manager';

export const AdCarousel: React.FC<AdCarouselProps> = memo(() => {
  // ✅ 注册所有资源
  useEffect(() => {
    // 注册定时器
    const timer1 = setTimeout(...);
    const resId1 = resourceManager.registerTimeout(timer1, 'AdCarousel timeout 1');
    
    // 注册事件监听器
    const handler = () => {...};
    window.addEventListener('customEvent', handler);
    const resId2 = resourceManager.registerEventListener(
      window, 
      'customEvent', 
      handler, 
      'AdCarousel event'
    );
    
    // 自动清理
    return () => {
      resourceManager.cleanup(resId1);
      resourceManager.cleanup(resId2);
    };
  }, []);
});
```

---

## 🔧 立即可执行的修复

### 快速修复 ad-carousel.tsx

我会帮你修复最严重的 setTimeout 泄漏问题：

```typescript
// 在组件顶部添加
const timeoutRefsRef = useRef<number[]>([]);

// 修改 fetchAdvertisements
const fetchAdvertisements = useCallback(async () => {
  try {
    console.log('🎬 AdCarousel: 请求广告列表...');
    
    // 刷新请求
    sendMessage({
      type: 'mcp-tool-call',
      tool_name: 'refresh_advertisements',
      arguments: {}
    });
    
    // ✅ 保存定时器 ID
    const timer1 = setTimeout(() => {
      sendMessage({
        type: 'mcp-tool-call',
        tool_name: 'get_advertisement_playlist',
        arguments: {}
      });
    }, 500);
    timeoutRefsRef.current.push(timer1);
    
    // ✅ 保存超时定时器 ID
    const timer2 = setTimeout(() => {
      if (isLoading) {
        console.error('❌ 广告列表请求超时');
        setIsLoading(false);
      }
    }, 8000);
    timeoutRefsRef.current.push(timer2);
    
  } catch (error) {
    console.error('❌ 广告列表获取失败:', error);
    setIsLoading(false);
  }
}, [sendMessage, isLoading]);

// ✅ 组件卸载时清理所有定时器
useEffect(() => {
  return () => {
    console.log('🧹 AdCarousel: 清理所有定时器');
    timeoutRefsRef.current.forEach(timer => clearTimeout(timer));
    timeoutRefsRef.current = [];
  };
}, []);
```

---

## 📊 性能问题评分

| 问题 | 严重性 | 频率 | 影响 |
|------|--------|------|------|
| setTimeout 泄漏 | 🔴 高 | 每次刷新 | 内存+CPU |
| adAudioMonitor 回调 | 🟡 中 | 状态变化时 | CPU |
| 事件监听器重复 | 🟡 中 | 依赖变化时 | 内存 |
| video 监听器 | 🟢 低 | once:true | 影响小 |

---

## 🛠️ 完整修复计划

### 阶段 1: 立即修复（今天）

1. **修复 setTimeout 泄漏**（ad-carousel.tsx）
   - 添加定时器引用数组
   - 组件卸载时清理所有定时器
   - 预计修复时间: 15 分钟

2. **稳定 adAudioMonitor 回调**
   - 使用 ref 避免重复订阅
   - 预计修复时间: 10 分钟

### 阶段 2: 深度优化（本周）

1. **启用 resourceManager**
   - 统一资源管理
   - 自动泄漏检测

2. **启用性能监控**
   - 监控组件渲染次数
   - 监控内存使用

### 阶段 3: 性能测试（本周）

1. 压力测试（刷新 20 次）
2. 内存分析（Chrome DevTools）
3. 性能Profile

---

## 🔍 如何验证修复

### 使用 Chrome DevTools

1. **打开 Performance Monitor**
   - F12 → 更多工具 → Performance monitor
   - 观察 JS heap size

2. **刷新测试**
   - 刷新 10 次
   - 观察内存是否持续增长
   - ✅ 正常：内存在刷新后回落
   - ❌ 泄漏：内存持续增长

3. **Performance Profile**
   - F12 → Performance
   - 录制刷新过程
   - 查看内存快照
   - 分析保留对象

---

## 🎯 临时缓解措施

在修复前，用户可以：

### 1. 定期清理缓存

```javascript
// 刷新 5 次后，在控制台执行
localStorage.clear();
location.reload();
```

### 2. 关闭性能密集功能

- 暂时关闭广告轮播
- 减少使用时间

### 3. 使用性能模式

如果有性能开关，启用它。

---

## 📋 检查清单

使用以下清单检查代码：

### ✅ useEffect 清理检查

- [ ] 所有 `setTimeout` 都在 cleanup 中 `clearTimeout`
- [ ] 所有 `setInterval` 都在 cleanup 中 `clearInterval`
- [ ] 所有 `addEventListener` 都在 cleanup 中 `removeEventListener`
- [ ] 所有 `subscribe` 都在 cleanup 中 `unsubscribe`
- [ ] 所有 MediaStream 都在 cleanup 中调用 `getTracks().forEach(t => t.stop())`
- [ ] 所有第三方库实例都在 cleanup 中 `destroy()`

### ✅ 依赖数组检查

- [ ] 避免在依赖数组中放入频繁变化的状态
- [ ] 使用 `useRef` + `useCallback` 稳定函数引用
- [ ] 使用 `useMemo` 稳定对象引用

---

## 🚀 推荐工具

### 1. React DevTools Profiler

```bash
npm install -D @welldone-software/why-did-you-render
```

### 2. 内存泄漏检测工具

Chrome DevTools → Memory → Heap Snapshot

### 3. 启用项目已有的工具

```typescript
// 已有但未充分使用
import { resourceManager } from '@/utils/resource-manager';
import { errorHandler } from '@/utils/error-handler';

// 开发环境启用自动清理
if (process.env.NODE_ENV === 'development') {
  resourceManager.enableAutoCleanup();
}
```

---

## 📊 预期修复效果

### Before（修复前）

```
刷新 1 次: 2 个 setTimeout + 1 个 callback
刷新 2 次: 4 个 setTimeout + 2 个 callback
刷新 3 次: 6 个 setTimeout + 3 个 callback
刷新 5 次: 10 个 setTimeout + 5 个 callback  ← 严重！
```

### After（修复后）

```
刷新 1 次: 0 个泄漏（全部清理）✅
刷新 2 次: 0 个泄漏（全部清理）✅
刷新 5 次: 0 个泄漏（全部清理）✅
刷新 20 次: 0 个泄漏（全部清理）✅
```

---

**立即行动**: 我会帮你修复 ad-carousel.tsx 的 setTimeout 泄漏问题！

