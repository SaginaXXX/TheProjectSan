# 性能问题深度排查清单 - 找出所有可能的卡顿原因

> **问题**: 偶尔开关网页多了还是会卡  
> **目标**: 彻底找出所有性能问题  
> **方法**: 系统性全面排查

---

## 🔍 已完成的修复

### ✅ 已修复的问题

1. ✅ service_context.py - 后台任务泄漏
2. ✅ ad-carousel.tsx - setTimeout 泄漏
3. ✅ vad-context.tsx - Immer 只读错误
4. ✅ store/index.ts - 生产环境配置

---

## 🚨 发现的潜在问题

### 🔴 问题 1: proxy_message_queue.py - Fire-and-Forget 任务（仍未修复）

**位置**: 第 114 行

```python
# ❌ 仍然存在的问题
asyncio.create_task(self._forward_message(message, sender_id))
```

**影响判断**：
```python
# 关键问题：你使用 proxy 模式吗？

检查方法：
cat conf.yaml | grep proxy
或
cat src/ai_chat/config_manager/*.py | grep proxy
```

**如果不用 proxy**：
- 🟢 这个问题不影响你
- ProxyHandler 根本不会被初始化

**如果使用 proxy**：
- 🔴 这是严重问题（每条消息泄漏 1 个任务）

---

### 🟡 问题 2: Agent 内部状态可能累积

**位置**: `agent/agents/basic_memory_agent.py`

**可能的问题**：

```python
class BasicMemoryAgent:
    def __init__(self):
        # Agent 有内部对话历史
        self.memory = []  # ❓ 是否会无限增长？
        self.context = []  # ❓ 是否会累积？
```

**检查方法**：

查看 Agent 是否有 `close()` 或 `reset()` 方法被调用：

```python
# service_context.py 第 251 行
if self.agent_engine and hasattr(self.agent_engine, "close"):
    await self.agent_engine.close()  # ✅ 有调用
```

**需要确认**：
- Agent.close() 是否清理了内部状态？
- 对话历史是否会无限增长？

---

### 🟡 问题 3: MCP Client 可能有残留连接

**位置**: `mcpp/mcp_client.py`

**观察日志**：
```
Closing MCPClient... and 4 active connections
```

**可能的问题**：
- MCP 有 4 个服务器连接
- 这些连接是否真的被关闭？
- 是否有残留的 subprocess 或 stdio 流？

**需要检查**：
- `aclose()` 方法是否完整？
- 是否有 subprocess 未终止？

---

### 🟡 问题 4: TTS 音频文件累积

**可能的问题**：

```python
# TTS 生成音频文件
audio_file_path = await tts_engine.async_generate_audio(...)

# 文件被删除了吗？
# tts_manager.py 第 162-164 行
finally:
    if audio_file_path:
        tts_engine.remove_file(audio_file_path)  # ✅ 有清理
```

**但**：如果异常发生在 `finally` 之前？

**检查方法**：
```bash
# 查看 cache 目录大小
du -sh cache/
ls cache/ | wc -l  # 文件数量
```

如果 cache 目录文件数量持续增长 → 有问题

---

### 🟢 问题 5: 聊天历史数据库增长

**可能的问题**：

```python
# 每次对话存储到数据库
store_message(
    conf_uid=context.character_config.conf_uid,
    history_uid=context.history_uid,
    role="ai",
    content=full_response,
    # ...
)
```

**检查**：
- 历史数据库文件在哪？
- 是否会无限增长？

```bash
# 查找数据库文件
find . -name "*.db" -o -name "*.sqlite"
du -sh chat_history/
```

**影响**：
- 🟢 数据库增长是正常的
- 但如果没有清理机制，可能会变慢

---

### 🟡 问题 6: default_context_cache 可能共享状态

**位置**: `routes.py` 第 55 行

```python
ws_handler = WebSocketHandler(default_context_cache)
```

**观察**：

```python
# WebSocketHandler 是每个路由创建一次（单例）
# 但 default_context_cache 是全局共享的

class WebSocketHandler:
    def __init__(self, default_context_cache: ServiceContext):
        self.default_context_cache = default_context_cache  # ✅ 共享
        
    async def _init_service_context(self, ...):
        # 每个客户端克隆 default_context_cache
        session_context = ServiceContext()
        await session_context.load_cache(
            config=self.default_context_cache.config.model_copy(deep=True),
            asr_engine=self.default_context_cache.asr_engine,  # ← 共享引用？
            tts_engine=self.default_context_cache.tts_engine,  # ← 共享引用？
            # ...
        )
```

**潜在问题**：
- ASR/TTS 引擎是共享的（不是深拷贝）
- 如果引擎内部有状态累积...
- 可能导致性能下降

---

### 🟢 问题 7: 前端 WebSocket 重连循环

**前端日志观察**：

你之前提到看到很多重连日志，可能是：

```javascript
🔄 WS schedule reconnect in 2000ms
🌐 WS connecting...
WebSocket connection failed
🚨 WebSocket连接错误
🔄 尝试恢复 websocket
```

**可能原因**：
- 前端一直尝试重连
- 后端已关闭但前端不知道
- 重连循环消耗资源

---

## 📋 完整排查计划

### 第 1 步：确认是否使用 proxy 模式

```bash
grep -r "enable_proxy" conf.yaml
grep -r "enable_proxy" characters/
```

**如果是 true**：
- 🔴 必须修复 proxy_message_queue
- 这可能是主要问题

**如果是 false**：
- 🟢 排除这个问题

---

### 第 2 步：检查 cache 目录

```bash
# Windows PowerShell
Get-ChildItem -Path cache\ | Measure-Object | Select-Object Count
Get-ChildItem -Path cache\ | Measure-Object -Property Length -Sum

# 应该看到：
# Count: <100 个文件（正常）
# Sum: <500MB（正常）

# 如果：
# Count: 1000+ 个文件 → 文件未删除 🔴
# Sum: 5GB+ → 严重泄漏 🔴
```

---

### 第 3 步：检查聊天历史大小

```bash
Get-ChildItem -Path chat_history\ -Recurse | Measure-Object -Property Length -Sum
```

**如果很大**（>1GB）：
- 可能需要定期清理
- 或添加自动归档

---

### 第 4 步：添加详细的性能监控日志

在 `websocket_handler.py` 的 `handle_disconnect` 添加：

```python
async def handle_disconnect(self, client_uid: str):
    # ... 现有清理逻辑
    
    # ✅ 添加详细监控
    logger.info(f"📊 性能统计:")
    logger.info(f"  - 活跃连接数: {len(self.client_connections)}")
    logger.info(f"  - 活跃对话任务: {len([t for t in self.current_conversation_tasks.values() if t and not t.done()])}")
    logger.info(f"  - 音频缓冲区: {len(self.received_data_buffers)}")
    
    # ✅ 检查 asyncio 任务数
    import asyncio
    all_tasks = asyncio.all_tasks()
    active_tasks = [t for t in all_tasks if not t.done()]
    logger.info(f"  - 全局 asyncio 任务数: {len(active_tasks)}")
    if len(active_tasks) > 20:
        logger.warning(f"  ⚠️ 任务数量异常: {len(active_tasks)}")
        for task in active_tasks[:5]:
            logger.warning(f"    - {task.get_name()}: {task}")
```

---

### 第 5 步：监控内存增长

```python
# 在 server.py 添加定期内存监控
import psutil
import os

async def monitor_memory():
    while True:
        await asyncio.sleep(60)  # 每分钟
        process = psutil.Process(os.getpid())
        mem_mb = process.memory_info().rss / 1024 / 1024
        logger.info(f"📊 内存使用: {mem_mb:.2f} MB")
        
        # 检查任务数
        tasks = [t for t in asyncio.all_tasks() if not t.done()]
        logger.info(f"📊 活跃任务数: {len(tasks)}")

# 启动监控
asyncio.create_task(monitor_memory())
```

---

## 🎯 立即可以做的检查

### 检查 1: 确认 proxy 模式

```powershell
Select-String -Path "conf.yaml" -Pattern "proxy"
```

### 检查 2: 查看 cache 目录

```powershell
Get-ChildItem -Path cache\ | Measure-Object
```

### 检查 3: 查看后端日志中的任务数

打开网页几次后，在后端添加临时日志：

```python
# 在 Python REPL 或添加到代码
import asyncio
tasks = asyncio.all_tasks()
print(f"当前任务数: {len(tasks)}")
for t in tasks:
    print(f"  - {t.get_name()}")
```

---

## 🔬 可能的其他原因

### 原因 A: LLM API 限流

如果你用的是外部 LLM API（如 OpenAI）：
- API 有速率限制
- 多次调用可能被限流
- 导致响应变慢

### 原因 B: 系统资源不足

```
CPU: 19（累积值，不是实时占用率）
内存: 2.1GB

# 需要检查实时值
```

### 原因 C: 网络延迟

如果后端和前端不在同一台机器：
- 网络延迟累积
- WebSocket 连接质量下降

---

## 🚀 建议的下一步行动

### 立即执行（5分钟）

1. **检查是否用 proxy**
   ```powershell
   Select-String -Path "conf.yaml" -Pattern "proxy"
   ```

2. **检查 cache 目录**
   ```powershell
   Get-ChildItem -Path cache\ | Measure-Object
   ```

3. **添加任务监控**
   在后端代码添加任务计数日志

### 根据结果决定

- 如果用 proxy → 修复 proxy_message_queue
- 如果 cache 很大 → 添加清理逻辑
- 如果任务数很多 → 找出未清理的任务

---

**告诉我这些检查的结果，我会给你精确的修复方案！**

