# 💻 核心修改代码示例

## 🎯 唯一需要修改的文件

**文件**: `src/ai_chat/mcpp/advertisement_server.py`

**修改行数**: 约50行

**修改难度**: 🟢 简单

**影响范围**: 🔴 关键 - 完成后S3即可生产使用

---

## 📋 修改清单

### 修改点1: 导入storage模块

**位置**: 文件顶部

```python
# ❌ 当前代码（第1-29行）
#!/usr/bin/env python3
"""
广告轮播管理 MCP 服务器
"""
import json
import sys
import re
import asyncio
from pathlib import Path
from typing import Dict, List, Optional, Any
from mcp.server.models import InitializationOptions
# ... 其他导入

# ✅ 修改后（添加storage导入）
#!/usr/bin/env python3
"""
广告轮播管理 MCP 服务器
支持本地存储和S3云存储
"""
import json
import sys
import re
import asyncio
from pathlib import Path
from typing import Dict, List, Optional, Any
from mcp.server.models import InitializationOptions
# ... 其他导入

# ✅ 新增: 导入storage模块
import os
import sys
from pathlib import Path

# 添加项目根目录到Python路径
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from src.ai_chat.storage.storage_factory import create_storage_service
from src.ai_chat.config_manager.system import MediaServerConfig
```

---

### 修改点2: 修改__init__方法

**位置**: 第104-155行

```python
# ❌ 当前代码
class AdvertisementServer:
    """广告轮播管理服务器"""
    
    def __init__(self, ads_dir: str = "ads", client_id: str = None):
        self.server = Server("advertisement-server")
        
        # 获取媒体配置
        self.media_config = get_media_config()
        
        # 获取CLIENT_ID
        import os
        self.client_id = client_id or os.getenv('CLIENT_ID') or self.media_config.client_id
        
        try:
            base_ads_dir = self.media_config.get_directory_path('ads')
            # 如果是多租户模式，添加CLIENT_ID子目录
            self.ads_dir = base_ads_dir / self.client_id
        except:
            # Fallback to provided directory
            self.ads_dir = Path(ads_dir) / self.client_id
        
        self.advertisements = {}
        self.supported_formats = {'.mp4', '.avi', '.mov', '.webm', '.mkv'}
        # ... 其他初始化
        
        # 确保广告目录存在（包括父目录）
        self.ads_dir.mkdir(parents=True, exist_ok=True)
        
        # 扫描可用的广告视频
        self._scan_advertisements()
        
        # 注册工具和资源
        self._register_tools()
        self._register_resources()
```

```python
# ✅ 修改后
class AdvertisementServer:
    """广告轮播管理服务器（支持本地和S3存储）"""
    
    def __init__(self, ads_dir: str = "ads", client_id: str = None):
        self.server = Server("advertisement-server")
        
        # 获取媒体配置
        self.media_config = get_media_config()
        
        # 获取CLIENT_ID
        import os
        self.client_id = client_id or os.getenv('CLIENT_ID') or getattr(self.media_config, 'client_id', 'default_client')
        
        # ✅ 新增: 创建存储服务（自动选择本地/S3）
        try:
            self.storage_service = create_storage_service(
                config=self.media_config,
                client_id=self.client_id
            )
            print(f"📦 使用存储服务: {self.storage_service.__class__.__name__} (CLIENT_ID: {self.client_id})")
        except Exception as e:
            print(f"⚠️ 创建存储服务失败: {e}")
            print(f"⚠️ 回退到本地存储模式")
            # 回退到本地模式
            from src.ai_chat.storage.local_service import LocalStorageService
            self.storage_service = LocalStorageService(
                client_id=self.client_id,
                base_directory="."
            )
        
        # ✅ 保留: ads_dir用于兼容性（仅在本地模式需要）
        try:
            base_ads_dir = self.media_config.get_directory_path('ads')
            self.ads_dir = base_ads_dir / self.client_id
        except:
            self.ads_dir = Path(ads_dir) / self.client_id
        
        self.advertisements = {}
        self.supported_formats = {'.mp4', '.avi', '.mov', '.webm', '.mkv'}
        # ... 其他初始化保持不变
        
        # ✅ 修改: 扫描方法改为async
        # 注意: __init__是同步的，但_scan需要async
        # 解决方案: 在这里调用同步版本，或在run()中异步调用
        
        # 暂时创建广告目录（本地模式兼容）
        if hasattr(self, 'ads_dir'):
            self.ads_dir.mkdir(parents=True, exist_ok=True)
        
        # ⚠️ 注意: _scan_advertisements改为async后，
        # 需要在run()方法中异步调用
        # 这里先注释掉，在run()中调用
        # self._scan_advertisements()
        
        # 注册工具和资源（保持不变）
        self._register_tools()
        self._register_resources()
```

---

### 修改点3: 修改_scan_advertisements方法

**位置**: 第157-218行

```python
# ❌ 当前代码
def _scan_advertisements(self):
    """
    扫描CLIENT_ID对应目录中的视频文件
    """
    self.advertisements.clear()
    
    if not self.ads_dir.exists():
        print(f"⚠️ Warning: Ads directory {self.ads_dir} does not exist")
        self.ads_dir.mkdir(parents=True, exist_ok=True)
        return
    
    ad_count = 0
    print(f"📁 扫描广告目录: {self.ads_dir} (CLIENT_ID: {self.client_id})")
    
    # 直接扫描CLIENT_ID目录中的视频文件
    for file_path in self.ads_dir.iterdir():
        if not (file_path.is_file() and file_path.suffix.lower() in self.supported_formats):
            continue
        
        try:
            file_size = file_path.stat().st_size
            ad_id = f"ad_{ad_count:03d}"
            
            ad_info = {
                "id": ad_id,
                "name": file_path.stem,
                "filename": file_path.name,
                "path": str(file_path),
                "url_path": f"/ads/{self.client_id}/{file_path.name}",  # ← 本地URL
                "size_bytes": file_size,
                "size_mb": round(file_size / (1024 * 1024), 2),
                "format": file_path.suffix.lower(),
                "category": "advertisement",
                "client_id": self.client_id
            }
            
            self.advertisements[ad_id] = ad_info
            ad_count += 1
            print(f"✅ [{self.client_id}] {ad_info['name']} ({ad_info['size_mb']} MB)")
        
        except Exception as e:
            print(f"❌ Error loading {file_path}: {e}")
    
    self.stats["total_ads"] = len(self.advertisements)
    print(f"\n🎬 广告服务器初始化完成: {len(self.advertisements)} 个广告已加载")
```

```python
# ✅ 修改后
async def _scan_advertisements(self):
    """
    扫描广告视频（支持本地存储和S3云存储）
    
    设计理念:
    - 使用storage_service统一接口
    - 自动适配本地/S3
    - CDN URL自动生成
    - CLIENT_ID自动隔离
    """
    self.advertisements.clear()
    
    try:
        print(f"📁 扫描广告资源 (CLIENT_ID: {self.client_id}, 存储: {self.storage_service.__class__.__name__})")
        
        # ✅ 使用storage_service统一接口
        files = await self.storage_service.list_files(category="ads")
        
        if not files:
            print(f"⚠️ 未找到广告视频 (CLIENT_ID: {self.client_id})")
            return
        
        ad_count = 0
        for file_info in files:
            # 过滤文件格式
            file_ext = Path(file_info["filename"]).suffix.lower()
            if file_ext not in self.supported_formats:
                continue
            
            ad_id = f"ad_{ad_count:03d}"
            
            # 构建广告信息
            ad_info = {
                "id": ad_id,
                "name": Path(file_info["filename"]).stem,
                "filename": file_info["filename"],
                "size_bytes": file_info["size_bytes"],
                "size_mb": file_info["size_mb"],
                "format": file_ext,
                
                # ✅ 使用storage_service生成URL（自动适配本地/CDN）
                "url": self.storage_service.get_file_url("ads", file_info["filename"]),
                # 本地模式: http://localhost:12393/ads/client_001/video.mp4
                # S3模式: https://cdn.example.com/client_001/ads/video.mp4
                
                # ✅ 保留url_path兼容旧代码
                "url_path": self.storage_service.get_file_url("ads", file_info["filename"]),
                
                "category": "advertisement",
                "client_id": self.client_id,
                
                # ✅ 新增: 存储类型标记
                "storage_type": getattr(self.media_config, 'storage_type', 'local')
            }
            
            self.advertisements[ad_id] = ad_info
            ad_count += 1
            
            # 打印加载信息
            storage_info = "CDN" if "cdn" in ad_info["url"].lower() else "Local"
            print(f"✅ [{self.client_id}] {ad_info['name']} ({ad_info['size_mb']} MB) [{storage_info}]")
        
        # 更新统计信息
        self.stats["total_ads"] = len(self.advertisements)
        print(f"\n🎬 广告服务器初始化完成: {len(self.advertisements)} 个广告已加载")
        
    except Exception as e:
        print(f"❌ 扫描广告失败: {e}")
        import traceback
        traceback.print_exc()
        self.advertisements = {}
        self.stats["total_ads"] = 0
```

---

### 修改点4: 修改run方法（调用异步扫描）

**位置**: 第755-778行

```python
# ❌ 当前代码
async def run(self):
    """Run the server using stdin/stdout streams"""
    from mcp.server.stdio import stdio_server
    
    async with stdio_server() as (read_stream, write_stream):
        try:
            await self.server.run(
                read_stream,
                write_stream,
                InitializationOptions(
                    server_name="advertisement-server",
                    server_version="0.1.0",
                    capabilities=self.server.get_capabilities(
                        notification_options=NotificationOptions(),
                        experimental_capabilities={},
                    ),
                ),
            )
        except Exception as e:
            print(f"Error running server: {e}")
            import traceback
            traceback.print_exc()
```

```python
# ✅ 修改后（在run方法开始时异步扫描）
async def run(self):
    """Run the server using stdin/stdout streams"""
    from mcp.server.stdio import stdio_server
    
    # ✅ 新增: 启动时异步扫描广告
    print("🔍 开始扫描广告资源...")
    await self._scan_advertisements()
    
    async with stdio_server() as (read_stream, write_stream):
        try:
            await self.server.run(
                read_stream,
                write_stream,
                InitializationOptions(
                    server_name="advertisement-server",
                    server_version="0.1.0",
                    capabilities=self.server.get_capabilities(
                        notification_options=NotificationOptions(),
                        experimental_capabilities={},
                    ),
                ),
            )
        except Exception as e:
            print(f"Error running server: {e}")
            import traceback
            traceback.print_exc()
```

---

### 修改点5: 修改refresh工具

**位置**: 工具调用处理（搜索 `"refresh"`）

```python
# ❌ 当前代码
if name == "refresh":
    # 重新扫描广告
    self._scan_advertisements()
    
    return [types.TextContent(
        type="text",
        text=json.dumps({
            "success": True,
            "total_ads": len(self.advertisements),
            "message": f"已刷新广告列表，当前共 {len(self.advertisements)} 个广告"
        })
    )]
```

```python
# ✅ 修改后（改为async调用）
if name == "refresh":
    # ✅ 重新扫描广告（异步，支持S3）
    await self._scan_advertisements()
    
    return [types.TextContent(
        type="text",
        text=json.dumps({
            "success": True,
            "total_ads": len(self.advertisements),
            "ads": list(self.advertisements.values()),
            "storage_type": getattr(self.media_config, 'storage_type', 'local'),
            "message": f"已刷新广告列表，当前共 {len(self.advertisements)} 个广告（来自{getattr(self.media_config, 'storage_type', 'local')}）"
        }, ensure_ascii=False)
    )]
```

---

## 📝 完整修改后的代码

### advertisement_server.py（关键部分）

```python
#!/usr/bin/env python3
"""
广告轮播管理 MCP 服务器
支持本地存储和S3云存储
"""

import json
import sys
import re
import asyncio
import argparse
import random
import os
from pathlib import Path
from typing import Dict, List, Optional, Any

from mcp.server.models import InitializationOptions
from mcp.server import NotificationOptions, Server
from mcp.types import Resource, Tool, TextContent
import mcp.types as types

# ✅ 添加: 导入storage模块
sys.path.insert(0, str(Path(__file__).parent.parent.parent))

try:
    from src.ai_chat.storage.storage_factory import create_storage_service
    from src.ai_chat.config_manager.system import MediaServerConfig
    STORAGE_MODULE_AVAILABLE = True
except ImportError as e:
    print(f"⚠️ Storage module not available: {e}")
    STORAGE_MODULE_AVAILABLE = False


class AdvertisementServer:
    """广告轮播管理服务器（支持本地和S3存储）"""
    
    def __init__(self, ads_dir: str = "ads", client_id: str = None):
        self.server = Server("advertisement-server")
        
        # 获取媒体配置
        self.media_config = get_media_config()
        
        # 获取CLIENT_ID
        self.client_id = client_id or os.getenv('CLIENT_ID') or getattr(self.media_config, 'client_id', 'default_client')
        
        # ✅ 创建存储服务（自动选择本地/S3）
        if STORAGE_MODULE_AVAILABLE:
            try:
                self.storage_service = create_storage_service(
                    config=self.media_config,
                    client_id=self.client_id
                )
                print(f"📦 存储服务: {self.storage_service.__class__.__name__} (CLIENT_ID: {self.client_id})")
            except Exception as e:
                print(f"⚠️ 创建存储服务失败，回退到本地模式: {e}")
                self.storage_service = None
        else:
            self.storage_service = None
        
        # 保留本地路径（用于本地模式兼容）
        try:
            base_ads_dir = self.media_config.get_directory_path('ads')
            self.ads_dir = base_ads_dir / self.client_id
        except:
            self.ads_dir = Path(ads_dir) / self.client_id
        
        # 如果是本地模式，确保目录存在
        if self.storage_service is None or getattr(self.media_config, 'storage_type', 'local') == 'local':
            self.ads_dir.mkdir(parents=True, exist_ok=True)
        
        self.advertisements = {}
        self.supported_formats = {'.mp4', '.avi', '.mov', '.webm', '.mkv'}
        self.current_index = 0
        
        # ... 其他初始化代码保持不变
        
        # 注册工具和资源
        self._register_tools()
        self._register_resources()
    
    async def _scan_advertisements(self):
        """
        扫描广告视频（支持本地存储和S3云存储）
        """
        self.advertisements.clear()
        ad_count = 0
        
        try:
            # ✅ 优先使用storage_service（支持S3）
            if self.storage_service:
                print(f"📁 扫描广告资源 (CLIENT_ID: {self.client_id}, 存储: {self.storage_service.__class__.__name__})")
                
                files = await self.storage_service.list_files(category="ads")
                
                for file_info in files:
                    file_ext = Path(file_info["filename"]).suffix.lower()
                    if file_ext not in self.supported_formats:
                        continue
                    
                    ad_id = f"ad_{ad_count:03d}"
                    
                    ad_info = {
                        "id": ad_id,
                        "name": Path(file_info["filename"]).stem,
                        "filename": file_info["filename"],
                        "size_bytes": file_info["size_bytes"],
                        "size_mb": file_info["size_mb"],
                        "format": file_ext,
                        
                        # ✅ 使用storage_service生成URL
                        "url": self.storage_service.get_file_url("ads", file_info["filename"]),
                        "url_path": self.storage_service.get_file_url("ads", file_info["filename"]),
                        
                        "category": "advertisement",
                        "client_id": self.client_id,
                        "storage_type": getattr(self.media_config, 'storage_type', 'local')
                    }
                    
                    self.advertisements[ad_id] = ad_info
                    ad_count += 1
                    
                    storage_info = "CDN" if "cdn" in ad_info["url"].lower() else "S3" if "s3" in ad_info["url"] else "Local"
                    print(f"✅ [{self.client_id}] {ad_info['name']} ({ad_info['size_mb']} MB) [{storage_info}]")
            
            # ❌ 回退: 使用本地文件系统（兼容旧版本）
            else:
                print(f"📁 扫描本地广告目录: {self.ads_dir} (CLIENT_ID: {self.client_id})")
                
                if not self.ads_dir.exists():
                    print(f"⚠️ 广告目录不存在: {self.ads_dir}")
                    return
                
                for file_path in self.ads_dir.iterdir():
                    if not (file_path.is_file() and file_path.suffix.lower() in self.supported_formats):
                        continue
                    
                    try:
                        file_size = file_path.stat().st_size
                        ad_id = f"ad_{ad_count:03d}"
                        
                        ad_info = {
                            "id": ad_id,
                            "name": file_path.stem,
                            "filename": file_path.name,
                            "path": str(file_path),
                            "url_path": f"/ads/{self.client_id}/{file_path.name}",
                            "url": f"/ads/{self.client_id}/{file_path.name}",
                            "size_bytes": file_size,
                            "size_mb": round(file_size / (1024 * 1024), 2),
                            "format": file_path.suffix.lower(),
                            "category": "advertisement",
                            "client_id": self.client_id,
                            "storage_type": "local"
                        }
                        
                        self.advertisements[ad_id] = ad_info
                        ad_count += 1
                        print(f"✅ [{self.client_id}] {ad_info['name']} ({ad_info['size_mb']} MB) [Local]")
                    
                    except Exception as e:
                        print(f"❌ Error loading {file_path}: {e}")
        
        except Exception as e:
            print(f"❌ 扫描广告失败: {e}")
            import traceback
            traceback.print_exc()
        
        finally:
            self.stats["total_ads"] = len(self.advertisements)
            print(f"\n🎬 广告服务器初始化完成: {len(self.advertisements)} 个广告已加载")
```

---

### 修改点6: 修改run方法

```python
async def run(self):
    """Run the server using stdin/stdout streams"""
    from mcp.server.stdio import stdio_server
    
    # ✅ 新增: 启动时扫描广告（异步）
    print("🔍 初始化广告服务器...")
    await self._scan_advertisements()
    
    async with stdio_server() as (read_stream, write_stream):
        try:
            await self.server.run(
                read_stream,
                write_stream,
                InitializationOptions(
                    server_name="advertisement-server",
                    server_version="0.1.0",
                    capabilities=self.server.get_capabilities(
                        notification_options=NotificationOptions(),
                        experimental_capabilities={},
                    ),
                ),
            )
        except Exception as e:
            print(f"Error running server: {e}")
            import traceback
            traceback.print_exc()
```

---

## 🧪 测试验证

### 测试1: 本地模式兼容性

```bash
# 1. 配置本地模式
# conf.yaml
storage_type: "local"

# 2. 启动MCP服务器
python -m src.ai_chat.mcpp.advertisement_server

# 3. 检查输出
# 应该显示:
# 📦 存储服务: LocalStorageService (CLIENT_ID: client_001)
# 📁 扫描广告资源 (CLIENT_ID: client_001, 存储: LocalStorageService)
# ✅ [client_001] video1 (50.00 MB) [Local]
# 🎬 广告服务器初始化完成: 2 个广告已加载

# ✅ 成功: 本地模式仍能正常工作
```

---

### 测试2: S3模式功能

```bash
# 1. 配置S3模式
# conf.yaml
storage_type: "s3"
s3_bucket: "my-ads-bucket"
cdn_url: "https://cdn.example.com"

# 2. 设置环境变量
export AWS_ACCESS_KEY=xxx
export AWS_SECRET_KEY=xxx
export CLIENT_ID=client_001

# 3. 上传测试文件到S3
aws s3 cp test.mp4 s3://my-ads-bucket/client_001/ads/test.mp4

# 4. 启动MCP服务器
python -m src.ai_chat.mcpp.advertisement_server

# 5. 检查输出
# 应该显示:
# 📦 存储服务: S3StorageService (CLIENT_ID: client_001)
# 📁 扫描广告资源 (CLIENT_ID: client_001, 存储: S3StorageService)
# ✅ [client_001] test (50.00 MB) [CDN]
# 🎬 广告服务器初始化完成: 1 个广告已加载

# ✅ 成功: S3模式正常工作
```

---

### 测试3: 端到端测试

```bash
# 1. Web控制面板上传视频
curl -F "file=@promo.mp4" \
     -F "client=client_001" \
     -F "category=ads" \
     http://localhost:12393/api/upload

# 2. 检查S3
aws s3 ls s3://my-ads-bucket/client_001/ads/
# 应该显示: promo_1730000000.mp4

# 3. 刷新MCP广告列表
# 前端调用 refresh 工具

# 4. 获取播放列表
# 前端调用 get_advertisement_playlist

# 5. 检查返回的URL
# 应该是: https://cdn.example.com/client_001/ads/promo_1730000000.mp4

# 6. 前端播放测试
# 应该能正常播放CDN视频

# ✅ 成功: 完整流程打通
```

---

## 📦 依赖检查

### Python依赖

```bash
# 检查boto3是否已安装
python -c "import boto3; print(boto3.__version__)"

# 如果未安装
pip install boto3

# 或添加到requirements.txt
echo "boto3>=1.26.0" >> requirements.txt
pip install -r requirements.txt
```

### 环境变量

```bash
# 检查必需的环境变量
env | grep -E "CLIENT_ID|AWS_ACCESS_KEY|AWS_SECRET_KEY|S3_BUCKET"

# 应该显示:
# CLIENT_ID=client_001
# AWS_ACCESS_KEY=AKIAIOSFODNN7EXAMPLE
# AWS_SECRET_KEY=wJalrXUtnFEMI/...
# S3_BUCKET=my-ads-bucket
```

---

## 🎯 验收标准

### 功能验收

- [ ] 本地模式能正常扫描广告
- [ ] S3模式能从S3加载广告
- [ ] get_advertisement_playlist返回正确URL
- [ ] refresh工具能刷新S3列表
- [ ] 前端能播放CDN视频
- [ ] 上传后自动刷新
- [ ] 删除后自动刷新
- [ ] CLIENT_ID隔离正确

### 性能验收

- [ ] 扫描100个广告 < 5秒
- [ ] refresh工具响应 < 3秒
- [ ] 本地模式性能不下降
- [ ] S3模式没有资源泄露

### 兼容性验收

- [ ] 支持本地存储（storage_type=local）
- [ ] 支持S3存储（storage_type=s3）
- [ ] 向后兼容旧配置
- [ ] 前端无需修改

---

## 🚦 回滚计划

### 如果修改后出现问题

```bash
# 1. 快速回滚到本地模式
# conf.yaml
storage_type: "local"  # ← 一行修改

# 2. 重启服务器
python run_server.py

# ✅ 立即恢复到修改前的状态

# 3. 检查问题
# 查看日志，定位错误

# 4. 修复后再切回S3
storage_type: "s3"
```

### 代码版本控制

```bash
# 修改前创建分支
git checkout -b feature/mcp-s3-support

# 修改代码
vim src/ai_chat/mcpp/advertisement_server.py

# 提交
git add src/ai_chat/mcpp/advertisement_server.py
git commit -m "feat: MCP广告服务器支持S3存储"

# 如果有问题，快速回滚
git checkout main

# 如果成功，合并到主分支
git checkout main
git merge feature/mcp-s3-support
```

---

## 🎯 总结

### 修改要点

1. **导入storage模块** - 添加import语句
2. **注入storage_service** - 在__init__中创建
3. **修改扫描方法** - 使用async和storage API
4. **修改run方法** - 异步调用扫描
5. **修改refresh工具** - 改为async调用

### 关键代码

```python
# 核心修改1: 创建存储服务
self.storage_service = create_storage_service(config, client_id)

# 核心修改2: 使用统一接口
files = await self.storage_service.list_files("ads")

# 核心修改3: 生成URL
url = self.storage_service.get_file_url("ads", filename)
```

### 工作量

- ✅ 代码修改: 2小时
- ✅ 测试验证: 1小时
- ✅ 文档更新: 1小时
- ✅ **总计: 4小时**

---

**相关文档**:
- [06-实施路线图](./06-实施路线图.md) - 详细步骤
- [07-常见问题FAQ](./07-常见问题FAQ.md) - 故障排除

**下一步**: 开始编码！💻

